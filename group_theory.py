import time

class GroupAction(object):
    """docstring for GroupAction"""
    def __init__(self, group, space, action = lambda g,x : x):
        self.group = group
        self.space = space
        self.action = action

    def act(self, group_element, element):
        return self.action(group_element, element)

    def in_setwise_stabilizer(self, group_element, subset):
        return preserves_subset(lambda x: self.action(group_element, x), subset)

def preserves_subset(transformation, subset):
    for element in subset:
        if transformation(element) not in subset:
            return False

    return True

class Group(object):
    def __init__(self, group_elements, operation):
        self.group_elements = set(group_elements)
        self.operation = operation

    def multiply(self, elem_1, elem_2):
        return self.operation(elem_1, elem_2)

#warning: does not terminate if semigroup generated by generators is not finite
def generate_finite_semigroup(generators, operation, bad_element_callback = lambda x: False):
    elements = set()

    elements_to_add = set()

    for generator in generators:
        # want to bail early if we don't like this element
        if bad_element_callback(generator):
            return False

        elements_to_add.add(generator)

    while elements_to_add:
        for element in elements_to_add:
            elements.add(element)

        recently_added_elements = elements_to_add
        elements_to_add = set()
        for generator in generators:
            for element in recently_added_elements:
                new_element = operation(generator, element)
                if new_element not in elements:
                    # want to bail early if we don't like this element
                    if bad_element_callback(new_element):
                        return False
                    elements_to_add.add(new_element)

    return elements

# given two group operations, create the direct sum
def product_operation(op1, op2):
    return lambda pair_1, pair_2: (op1(pair_1[0], pair_2[0]), op2(pair_1[1], pair_2[1]))

# tests if there is an isomorphism mapping generators_1[i] to generators_2[i] for all i
# this is true if and only if the the subgroup generated by all tuples of the form (generators_1[i], generators_2[i]) in
# the direct product is the graph of an isomorphism (i.e., satisfies vertical and horizonal line tests)
# returns False if no such isomorphism exists and returns a tuple of maps otherwise, where each map is the isomorphism
def test_isomorphism(generators_1, generators_2, op_1, op_2):
    if len(generators_1) != len(generators_2):
        print ("generators not same length!")
        return False

    generators = [(generators_1[i], generators_2[i]) for i in range(len(generators_1))]

    x_to_y_map = {}
    y_to_x_map = {}
    product_subgroup = generate_finite_semigroup(generators, product_operation(op_1, op_2), 
        lambda candidate_tuple: line_test_helper(candidate_tuple, x_to_y_map, y_to_x_map))

    if product_subgroup == False:
        return False
    
    return (x_to_y_map, y_to_x_map)


def line_test_helper(candidate_tuple, x_to_y_map, y_to_x_map):
    if (candidate_tuple[0] in x_to_y_map) or (candidate_tuple[1] in y_to_x_map):
        return True

    x_to_y_map[candidate_tuple[0]] = candidate_tuple[1]
    y_to_x_map[candidate_tuple[1]] = candidate_tuple[0]

    return False


def multiply_permutations(perm_1, perm_2):
    result = []
    assert(len(perm_1) == len(perm_2))
    for value in perm_2:
        result.append(perm_1[value])

    return tuple(result)


def calculate_setwise_stabilizer(group_action, subset):
    stabilizer = set()
    for group_element in group_action.group.group_elements:
        in_stabilizer = True
        for element in subset:
            if group_action.act(group_element, element) not in subset:
                in_stabilizer = False
                break

        if in_stabilizer:
            stabilizer.add(group_element)

    return stabilizer

def generate_permutation_group(generator_set):
    group_elements = generate_finite_semigroup(generator_set, multiply_permutations)

    return Group(group_elements, multiply_permutations)

def generate_permutation_group_action(generator_set):
    acting_set = set(range(len(list(generator_set)[0])))

    return GroupAction(generate_permutation_group(generator_set), acting_set, lambda g,x: g[x])

#generate the symmetric group using the transpositions that swap adjacent elements
def generate_symmetric_group(n):
    generators = set()
    for i in range(n-1):
        swap_i = list(range(n))
        swap_i[i] = i+1
        swap_i[i+1] = i

        swap_i = tuple(swap_i)

        generators.add(swap_i)

    return generate_permutation_group(generators)

def is_identity_perm(perm):
    return ( perm == tuple(range(len(perm))) )

def perm_group_is_transitive(group_elements):
    space = None
    for group_element in group_elements:
        if space is None:
            space = set(range(len(group_element)))

        if group_element[0] in space:
            space.remove(group_element[0])

        if not space:
            return True

    return False

def construct_k_distinct_tuples(input_list, k):
    if k == 1:
        return [tuple([x]) for x in input_list]

    k_minus_one_tuples = construct_k_distinct_tuples(input_list, k -1)

    result = []
    for tuple_ in k_minus_one_tuples:
        for x in input_list:
            if x not in tuple_:
                result.append(tuple(list(tuple_) + [x]))

    return result

# returns some element in a non-empty set
def get_an_element(given_set):
    for x in given_set:
        return x

def get_cycle_decomposition(perm):
    unvisited_points = set(range(len(perm)))
    cycles = []

    while unvisited_points:
        current_point = get_an_element(unvisited_points)

        cycle_set = set()
        cycle_list = []
        while current_point not in cycle_set:
            cycle_set.add(current_point)
            cycle_list.append(current_point)
            unvisited_points.remove(current_point)
            current_point = perm[current_point]

        cycles.append(cycle_list)

    return cycles

def get_cycle_lengths(perm):
    cycle_decomp = get_cycle_decomposition(perm)

    cycle_length_counter = dict()

    for cycle_list in cycle_decomp:
        if len(cycle_list) not in cycle_length_counter:
            cycle_length_counter[len(cycle_list)] = 0

        cycle_length_counter[len(cycle_list)] += 1

    return cycle_length_counter

def perms_are_conjugate(perm1, perm2):
    return (get_cycle_lengths(perm1) == get_cycle_lengths(perm2))

def perm_inverse(perm):
    inverse_dict = dict()

    for i in range(len(perm)):
        inverse_dict[perm[i]] = i

    return tuple([inverse_dict[i] for i in range(len(perm))])

def sets_are_conjugates(set1, set2, conjugator_set, operation):
    for conjugator in conjugator_set:
        invariant = True
        conjugator_inverse = perm_inverse(conjugator)
        for g in set1:
            if operation(conjugator, operation(g, conjugator_inverse)) not in set2:
                invariant = False
                break
        if invariant:
            return True

    return False

def get_perm_conjugators(perm1, perm2, conjugator_candidates):
    conjugators = set()
    if perms_are_conjugate(perm1, perm2):
        for conjugator_candidate in conjugator_candidates:
            if perm2 == multiply_permutations(conjugator_candidate, multiply_permutations(perm1, perm_inverse(conjugator_candidate))):
                conjugators.add(conjugator_candidate)

    return conjugators

def count_fixed_points(perm):
    total = 0
    for i in range(len(perm)):
        total += (i == perm[i])
    return total

def permutations_conjugate(perm_1, perm_2):
    cycle_decomp_1 = get_cycle_decomposition(perm1)
    cycle_decomp_2 = get_cycle_decomposition(perm2)
    
